"""
ClamAV-backed malware scanner.

Uses the clamd socket protocol (TCP or UNIX). Returns the same shape as
the heuristic scanner so the API schema stays consistent.
"""
from __future__ import annotations

import hashlib
import io
from typing import Dict, Optional, Tuple

# pragma: no cover - external dependency
try:
    import clamd
except Exception as exc:  # pragma: no cover - external dependency
    clamd = None  # type: ignore
    CLAMD_IMPORT_ERROR = exc
else:
    CLAMD_IMPORT_ERROR = None

# pragma: no cover - external dependency
class ClamAVScanner:
    """Simple wrapper around clamd for streaming scans."""

    # pragma: no cover - external dependency
    def __init__(self, cfg: Optional[Dict] = None):
        cfg = cfg or {}
        ccfg = cfg.get("clamav", {}) or {}
        if clamd is None:
            raise RuntimeError(f"clamd client not available: {CLAMD_IMPORT_ERROR}")

        self.engine = "clamav"
        self.threshold = float(cfg.get("threshold", 0.5))  # cosmetic; ClamAV is binary
        self.timeout = int(ccfg.get("timeout", 30))
        self.host = ccfg.get("host", "localhost")
        self.port = int(ccfg.get("port", 3310))
        self.unix_socket = ccfg.get("unix_socket")
        self._client = self._build_client()

    # pragma: no cover - external dependency
    def _build_client(self):
        if self.unix_socket:
            return clamd.ClamdUnixSocket(path=self.unix_socket, timeout=self.timeout)
        return clamd.ClamdNetworkSocket(host=self.host, port=self.port, timeout=self.timeout)

    # pragma: no cover - external dependency
    def ping(self) -> bool:
        try:
            return bool(self._client.ping())
        except Exception:
            return False

    # pragma: no cover - external dependency
    def _extract_status(self, result: Dict) -> Tuple[Optional[str], Optional[str]]:
        """
        clamd returns {'stream': ('FOUND', 'Eicar-Test-Signature')} or similar.
        """
        if not isinstance(result, dict) or not result:
            return None, None
        entry = next(iter(result.values()))
        if isinstance(entry, tuple) and len(entry) >= 2:
            return entry[0], entry[1]
        return None, None

    # pragma: no cover - external dependency
    def scan(self, data: bytes, filename: Optional[str] = None, content_type: Optional[str] = None) -> Dict:
        if not data:
            raise ValueError("Uploaded file is empty")

        size = len(data)
        sha256 = hashlib.sha256(data).hexdigest()
        # pragma: no cover - external dependency
        try:
            result = self._client.instream(io.BytesIO(data))
        except Exception as exc:
            raise RuntimeError(f"ClamAV scan failed: {exc}") from exc

        status, signature = self._extract_status(result)
        infected = status == "FOUND"
        probability = 0.99 if infected else 0.01
        label = int(infected)

    # pragma: no cover - external dependency
        indicators = []
        if infected:
            indicators.append(f"clamav detection: {signature or 'unknown signature'}")
        else:
            indicators.append("clamav: clean")

        features = {
            "engine": self.engine,
            "status": status or "OK",
            "signature": signature,
            "size_bytes": size,
        }
        # pragma: no cover - external dependency
        return {
            "label": label,
            "probability": probability,
            "threshold": self.threshold,
            "sha256": sha256,
            "size": size,
            "indicators": indicators,
            "features": features,
            "filename": filename,
            "content_type": content_type,
        }
