import hashlib
import io
import math
from collections import Counter
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import zipfile


def _shannon_entropy(data: bytes) -> float:
    """Return Shannon entropy (base 2) of the given bytes."""
    if not data:
        return 0.0
    counts = Counter(data)
    length = float(len(data))
    entropy = 0.0
    for count in counts.values():
        p = count / length
        entropy -= p * math.log2(p)
    return entropy


class HeuristicMalwareScanner:
    """
    Lightweight heuristic malware scanner.

    This is *not* a replacement for a full AV engine, but it provides
    deterministic scoring that the API can use until integrated with a
    production-grade malware analysis pipeline.
    """

    def __init__(self, cfg: Optional[Dict] = None):
        cfg = cfg or {}
        scfg = cfg.get("scanner", {})

        self.threshold = float(cfg.get("threshold", 0.6))
        self.max_bytes = int(scfg.get("max_bytes", 20 * 1024 * 1024))  # 20 MB cap for entropy/string search
        self.high_entropy_threshold = float(scfg.get("high_entropy_threshold", 7.2))

        self.suspicious_extensions = {
            str(ext).lower()
            for ext in scfg.get(
                "suspicious_extensions",
                [
                    ".exe", ".dll", ".scr", ".bat", ".cmd", ".ps1", ".vbs", ".js",
                    ".jar", ".wsf", ".msi", ".lnk", ".apk",
                ],
            )
        }
        self.suspicious_archive_extensions = {
            str(ext).lower()
            for ext in scfg.get(
                "suspicious_archive_extensions",
                [".zip", ".rar", ".7z", ".iso"],
            )
        }
        self.suspicious_strings = [
            str(s).lower()
            for s in scfg.get(
                "suspicious_strings",
                [
                    "powershell",
                    "cmd.exe",
                    "rundll32",
                    "wscript.shell",
                    "javascript:",
                    "invoke-expression",
                    "virtualalloc",
                    "base64 -d",
                    "downloadstring",
                    "/bin/sh",
                    "wget ",
                    "curl ",
                    "http://",
                    "https://",
                    "vbaProject.bin",
                    "autoopen",
                    "document_close",
                ],
            )
        ]
        self.max_indicator_bonus = float(scfg.get("max_indicator_bonus", 0.25))

    def _trim_payload(self, data: bytes) -> Tuple[bytes, bool]:
        if self.max_bytes and len(data) > self.max_bytes:
            return data[: self.max_bytes], True
        return data, False

    def scan(
        self,
        data: bytes,
        filename: Optional[str] = None,
        content_type: Optional[str] = None,
    ) -> Dict:
        original_size = len(data)
        working, truncated = self._trim_payload(data)
        entropy = _shannon_entropy(working)
        sha256 = hashlib.sha256(data).hexdigest()

        indicators: List[str] = []
        score = 0.0

        ext = Path(filename).suffix.lower() if filename else ""
        if ext in self.suspicious_extensions:
            score += 0.25
            indicators.append(f"suspicious extension: {ext}")
        elif ext in self.suspicious_archive_extensions:
            indicators.append(f"archive file: {ext}")

        # Executable signatures
        if working.startswith(b"MZ"):
            score += 0.30
            indicators.append("portable executable (MZ header)")
        elif working.startswith(b"\x7fELF"):
            score += 0.30
            indicators.append("ELF executable header")
        elif working.startswith(b"#!"):
            score += 0.15
            indicators.append("script interpreter shebang")

        # Office macros / suspicious OLE tokens
        macro_tokens = [b"vbaProject.bin", b"AutoOpen", b"Document_Open", b"Document_Close"]
        if any(token in working for token in macro_tokens):
            score += 0.25
            indicators.append("office macro indicators present")

        # Suspicious string search (case insensitive)
        lowered = working.lower()
        hit_strings = [s for s in self.suspicious_strings if s.encode("utf-8", "ignore") in lowered]
        if hit_strings:
            bonus = min(0.1 * len(hit_strings), 0.3)
            score += bonus
            indicators.append(f"suspicious strings matched: {', '.join(sorted(set(hit_strings))[:5])}")

        # High entropy often suggests packed/obfuscated payloads
        if entropy >= self.high_entropy_threshold:
            score += 0.2
            indicators.append(f"high entropy ({entropy:.2f} bits)")

        # Inspect zip archives for embedded executables or macros
        if zipfile.is_zipfile(io.BytesIO(working)):
            indicators.append("zip archive detected")
            try:
                with zipfile.ZipFile(io.BytesIO(working)) as zf:
                    archive_hits: List[str] = []
                    for info in zf.infolist():
                        sub_ext = Path(info.filename).suffix.lower()
                        if sub_ext in self.suspicious_extensions:
                            archive_hits.append(info.filename)
                        if "vbaProject.bin" in info.filename:
                            archive_hits.append(info.filename + " (macro project)")
                    if archive_hits:
                        score += 0.25
                        indicators.append(
                            f"archive contains high-risk entries: {', '.join(archive_hits[:3])}"
                        )
            except zipfile.BadZipFile:
                indicators.append("zip header corrupted (could be intentionally tampered)")
                score += 0.1

        if truncated:
            indicators.append(
                f"payload truncated to {self.max_bytes:,} bytes for analysis (original {original_size:,} bytes)"
            )
            score += 0.1

        # Combine indicator count as small bonus to push probability for multiple factors
        score += min(len(indicators) * 0.02, self.max_indicator_bonus)
        score = max(0.0, min(score, 1.2))
        probability = max(0.01, min(0.99, 0.05 + score))
        label = int(probability >= self.threshold)

        features = {
            "size_bytes": original_size,
            "entropy": round(entropy, 4),
            "truncated": truncated,
            "indicator_count": len(indicators),
            "extension": ext or None,
            "content_type": content_type,
        }

        return {
            "label": label,
            "probability": round(probability, 6),
            "threshold": self.threshold,
            "sha256": sha256,
            "size": original_size,
            "indicators": indicators,
            "features": features,
            "filename": filename,
            "content_type": content_type,
        }
